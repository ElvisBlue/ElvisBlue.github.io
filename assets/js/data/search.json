[ { "title": "Cracking a chess engine - ziy by s4r", "url": "/posts/ziy-solution/", "categories": "Writeup, Reverse Engineering", "tags": "crackme", "date": "2023-07-02 09:00:00 +0700", "snippet": "How to find a good crackme on crackmes.one? The answer is simple: good crackme usually created by skill reverser. ziy for example. I downloaded it 1 year ago but still have no time to try it until ...", "content": "How to find a good crackme on crackmes.one? The answer is simple: good crackme usually created by skill reverser. ziy for example. I downloaded it 1 year ago but still have no time to try it until now. It takes me about 1 week to solve this.Challenge overviewAn ELF file which ask user to input 60 characters password. No obfuscation, no anti-debug or anti-disassembler trick but the code is quiet large.Reverse engineering partClearly this is the hardest part of the challenge. I can not tell the reverse engineering detail here because it would be too long. Instead I will tell some interesting step I did to reverse this.Suspicious constantIf you look at function 0x16B5, you will notice that it returns a constant from a global int64_t array. Quickly google some constant (for example 0x1100110A00000000) lead me to some open source chess engine.By knowning that I am dealing with a chess engine help alot. At least I know how to rename function or struct field correctly.Help from open source chess engineReading open source chess engine writting in C/C++ (for example surge) also help. It gives me basic concept how does a chess engine work. Here is a few functions which I was able to reconagize after reading the source.__int64 __fastcall ziy_get_knight_attack(ziy_t *ziy_obj, int square){ return KNIGHT_ATTACKS[square];}__int64 __fastcall ziy_get_pawn_attack(ziy_t *ziy_obj, int pos, int color){ if ( color == WHITE ) return WHITE_PAWN_ATTACKS[pos]; else return BLACK_PAWN_ATTACKS[pos];}__int64 __fastcall ziy_get_all_attack(ziy_t *ziy_obj, int color){ char king_pos; // [rsp+14h] [rbp-1Ch] int i; // [rsp+18h] [rbp-18h] int j; // [rsp+1Ch] [rbp-14h] int curr_piece; // [rsp+20h] [rbp-10h] int chess_piece; // [rsp+24h] [rbp-Ch] __int64 moves; // [rsp+28h] [rbp-8h] moves = 0LL; king_pos = -1; for ( i = 0; i &lt;= 63; ++i ) { chess_piece = ziy_obj-&gt;chess_board[i]; if ( (chess_piece == KING || chess_piece == -97) &amp;&amp; is_same_color(chess_piece, color) ) king_pos = i; } if ( color == WHITE ) clear_mask(ziy_obj-&gt;board_white_mask, king_pos); else clear_mask(ziy_obj-&gt;board_black_mask, king_pos); for ( j = 0; j &lt;= 63; ++j ) { curr_piece = ziy_obj-&gt;chess_board[j]; if ( curr_piece &amp;&amp; !is_same_color(curr_piece, color) ) { switch ( curr_piece ) { case KNIGHT: case 0xFFFFFFE1: moves |= ziy_get_knight_attack(ziy_obj, j); break; case BISHOP: case 0xFFFFFFE3: moves |= ziy_get_bishop_attack(ziy_obj, j); break; case KING: case 0xFFFFFF9F: moves |= ziy_get_king_attack(ziy_obj, j); break; case QUEEN: case 0xFFFFFFAD: moves |= ziy_get_queen_attack(ziy_obj, j); break; case ROOK: case 0xFFFFFFC5: moves |= ziy_get_rook_attack(ziy_obj, j); break; case PAWN: case 0xFFFFFFEF: moves |= ziy_get_pawn_attack(ziy_obj, j, -color); break; } } } if ( color == WHITE ) set_board_mask(ziy_obj-&gt;board_white_mask, king_pos); else set_board_mask(ziy_obj-&gt;board_black_mask, king_pos); return moves;}__int64 __fastcall ziy_is_check(ziy_t *ziy_obj, int color){ char king_pos; // [rsp+14h] [rbp-8h] int i; // [rsp+18h] [rbp-4h] king_pos = -1; for ( i = 0; i &lt;= 63; ++i ) { if ( ziy_obj-&gt;chess_board[i] == KING * color ) king_pos = i; } if ( color == WHITE ) return (ziy_obj-&gt;all_attacks_to_white_bitmask &gt;&gt; king_pos) &amp; 1; else return (ziy_obj-&gt;all_attacks_to_black_bitmask &gt;&gt; king_pos) &amp; 1LL;}There are more but I will not show all of them because this post would be too long. By keep reading the source, rename the fields I was able to reconagize most of the code and understand the chess engine better.Chess engine struct and definestruct __attribute__((packed)) __attribute__((aligned(4))) ziy_t{ int chess_board[64]; _DWORD color; _DWORD present_mask; move_t move_table_array[150]; _DWORD move_cnt; int field_268C; _QWORD pawn_first_move_mask; __int64 board_white_mask; __int64 board_black_mask; unsigned __int64 all_attacks_to_white_bitmask; _QWORD all_attacks_to_black_bitmask; _DWORD is_finish; _DWORD turn; _QWORD hash; _DWORD dword26C8; _BYTE gap26CC[4788]; _DWORD dword3980;};struct move_t{ int chess_piece; int from_pos; int field_8; int to_pos; int is_next_pos_have_piece; int field_14; int is_castling_move; int field_1C; __int64 field_20; int is_en_passant; int is_pawn_first_move; int not_checkmate_move; int field_34; __int64 field_38;};enum piece_t{ PAWN = 0x11, BISHOP = 0x1D, KNIGHT = 0x1F, ROOK = 0x3B, QUEEN = 0x53, KING = 0x61,};enum color_t{ WHITE = 0x1, BLACK = 0xFFFFFFFF,};There are still some unknown fields but this is enough for me to understand the crackme.The chess AIThe crackme also implement a simple AI.int __fastcall ziy_ai_move(ziy_t *ziy, _BYTE *move_info){ ziy_get_all_not_check_moves(ziy, ziy-&gt;color); if ( ziy-&gt;move_cnt ) { ziy_extract_move_info(ziy, ziy-&gt;move_table_array, move_info); ziy_apply_move(ziy, ziy-&gt;move_table_array); ziy_get_all_not_check_moves(ziy, ziy-&gt;color); if ( ziy_is_checkmate(ziy, ziy-&gt;color) ) { ziy-&gt;is_finish = 1; ziy-&gt;turn = ziy-&gt;color; } else if ( ziy_is_not_checkmate(ziy, ziy-&gt;color) ) { ziy-&gt;is_finish = 1; } return 0; } else { ziy-&gt;is_finish = 1; if ( ziy_is_checkmate(ziy, ziy-&gt;color) ) ziy-&gt;turn = -ziy-&gt;color; return 0; }}The logic of AI is very simple. First, it list all possible moves and store them in ziy-&gt;move_table_array. Then it take the first move in ziy-&gt;move_table_array and play it.The logic of password checkingunsigned int __fastcall parse_x(char a1){ return a1 - 0x6E;}unsigned int __fastcall parse_y(char a1){ return a1 - 0x69;}__int64 __fastcall ziy_get_move_from_input(ziy_t *a1, unsigned __int8 *a2, move_t *move){ unsigned int y2; // eax unsigned int x1; // [rsp+20h] [rbp-18h] unsigned int y1; // [rsp+24h] [rbp-14h] unsigned int x2; // [rsp+28h] [rbp-10h] x1 = parse_x(*a2); y1 = parse_y(a2[1]); x2 = parse_x(a2[2]); y2 = parse_y(a2[3]); move-&gt;from_pos = x1 + 8 * y1; move-&gt;to_pos = x2 + 8 * y2; move-&gt;field_14 = 0; move-&gt;is_castling_move = 0; move-&gt;field_8 = 0; return 0LL;}int __fastcall ziy_player_move(ziy_t *ziy, unsigned __int8 *input, int move_info){ move_t move; // [rsp+30h] [rbp-50h] BYREF unsigned __int64 v6; // [rsp+78h] [rbp-8h] v6 = __readfsqword(0x28u); memset(&amp;move, 0, sizeof(move)); if ( ziy-&gt;is_finish ) return 0xFFFFFFFC; if ( (unsigned int)ziy_get_move_from_input(ziy, input, &amp;move) ) return 0xFFFFFFFE; ziy_get_all_not_check_moves(ziy, ziy-&gt;color); if ( (unsigned int)ziy_get_full_player_move(ziy, &amp;move, move_info) ) return 0xFFFFFFFD; ziy_apply_move(ziy, &amp;move); ziy_get_all_not_check_moves(ziy, ziy-&gt;color); if ( ziy_is_checkmate(ziy, ziy-&gt;color) ) { ziy-&gt;is_finish = 1; ziy-&gt;turn = ziy-&gt;color; } else if ( ziy_is_not_checkmate(ziy, ziy-&gt;color) ) { ziy-&gt;is_finish = 1; } return 0;}int __fastcall main(int a1, char **a2, char **a3){ unsigned int seed; // eax int is_valid; // [rsp+0h] [rbp-B0h] int i; // [rsp+4h] [rbp-ACh] ziy_t *ziy_obj; // [rsp+18h] [rbp-98h] __int64 data_buffer_array[5]; // [rsp+20h] [rbp-90h] _BYTE move_info[10]; // [rsp+49h] [rbp-67h] BYREF char dest[12]; // [rsp+53h] [rbp-5Dh] BYREF char v11; // [rsp+5Fh] [rbp-51h] char input[72]; // [rsp+60h] [rbp-50h] BYREF unsigned __int64 v13; // [rsp+A8h] [rbp-8h] v13 = __readfsqword(0x28u); seed = time(0LL); srand(seed); data_buffer_array[0] = (__int64)g_board_1; data_buffer_array[1] = (__int64)g_board_2; data_buffer_array[2] = (__int64)g_board_3; data_buffer_array[3] = (__int64)g_board_4; data_buffer_array[4] = (__int64)g_board_5; is_valid = 1; printf(\"Enter the password: \"); fgets(input, 70, stdin); input[strcspn(input, \"\\n\")] = 0; if ( (unsigned int)strlen(input) == 60 ) { for ( i = 0; i &lt;= 4; ++i ) { memcpy(dest, &amp;input[12 * i], sizeof(dest)); v11 = 0; ziy_obj = ziy_create(); ziy_set_board(ziy_obj, (int *)data_buffer_array[i]); if ( ziy_player_move(ziy_obj, (unsigned __int8 *)dest, 1) || ziy_ai_move(ziy_obj, move_info) || ziy_player_move(ziy_obj, (unsigned __int8 *)&amp;dest[4], 1) || ziy_ai_move(ziy_obj, move_info) || ziy_player_move(ziy_obj, (unsigned __int8 *)&amp;dest[8], 1) || ziy_ai_move(ziy_obj, move_info) ) { puts(\"error\"); return 0; } is_valid &amp;= (ziy_obj-&gt;turn == WHITE) &amp; ziy_obj-&gt;is_finish; ziy_free(ziy_obj); } if ( is_valid ) printf(\"Good job! The flag is brb{\\%s}\\n\", input); else puts(\"error\"); return 0; } else { puts(\"error\"); return 0; }}Password will be convertered to moves. User plays white and the goal is checkmate the AI in 3 moves. There are total 5 matches user have to win to pass the password check.Match 1Match 2Match 3Match 4Match 5Fighting with chess AITo fight with chess AI, There are 2 problem need to be solved Find a way to interactive with chess match Play chess well enough to win the AI in 3 movesPlaying chess through debuggerMy method to solve first problem is writing a script to help me play chess through debugger. By knowning the chess struct and define, I am able to print out the chess board. My script written for IDA debugger but same concept can be applied to other debugger like binary ninja (cheaper alternative) or gdb (free).import ctypesimport chessfrom idautils import *from idc import *from idaapi import *KNIGHT = 31KING = 97PAWN = 17BISHOP = 29ROOK = 59QUEEN = 83def data_to_FENs(data): fens = \"\" for i in range(0, 8): empty = 0 line = \"\" for j in range(0, 8): c = ctypes.c_long(data[i * 8 + j]).value if c == 0: empty += 1 else: if c in [KNIGHT, -KNIGHT]: if empty &gt; 0: line += str(empty) empty = 0 line += [\"N\", \"n\"][[KNIGHT, -KNIGHT].index(c)] elif c in [KING, -KING]: if empty &gt; 0: line += str(empty) empty = 0 line += [\"K\", \"k\"][[KING, -KING].index(c)] elif c in [PAWN, -PAWN]: if empty &gt; 0: line += str(empty) empty = 0 line += [\"P\", \"p\"][[PAWN, -PAWN].index(c)] elif c in [BISHOP, -BISHOP]: if empty &gt; 0: line += str(empty) empty = 0 line += [\"B\", \"b\"][[BISHOP, -BISHOP].index(c)] elif c in [ROOK, -ROOK]: if empty &gt; 0: line += str(empty) empty = 0 line += [\"R\", \"r\"][[ROOK, -ROOK].index(c)] elif c in [QUEEN, -QUEEN]: if empty &gt; 0: line += str(empty) empty = 0 line += [\"Q\", \"q\"][[QUEEN, -QUEEN].index(c)] elif c != 0: if empty &gt; 0: line += str(empty) empty = 0 line += \"?\" print(c) if empty &gt; 0: line += str(empty) line += \"/\" fens = line + fens return fens[:-1] def ida_debug_print_board(ziy_addr): data = [] for i in range(0, 64): data.append(get_dword(4 * i + ziy_addr)) fens = data_to_FENs(data) print(\"FENs: %s\" % fens) board = chess.Board(fens) print(board)if __name__ == \"__main__\": ida_debug_print_board(get_reg_value(\"rdi\"))Run script before crackme call ziy_player_move or ziy_ai_move will print the chess board. Also by knowing how does input converted to moves, I’m able to writing function to reverse moves to input.def move_to_input(from_x, from_y, to_x, to_y): result = \"\" result += chr(from_x + 0x6E) result += chr(from_y + 0x69) result += chr(to_x + 0x6E) result += chr(to_y + 0x69) return resultBy printing chess board and keep updating my moves to memory through debugger, I am finally able to play chess with AI. I know this is inconvenient but It works .Help from stockfishSecond problem can be solved by using stockfish. For anyone who doesn’t know stockfish is the best open source chess AI until now.Final solving scriptAfter playing for a while, I am able to record all moves and get the final password.import ctypesimport chessKNIGHT = 31KING = 97PAWN = 17BISHOP = 29ROOK = 59QUEEN = 83def move_to_input(from_x, from_y, to_x, to_y): result = \"\" result += chr(from_x + 0x6E) result += chr(from_y + 0x69) result += chr(to_x + 0x6E) result += chr(to_y + 0x69) return resultif __name__ == \"__main__\": solution_1 = [(6, 1, 6, 6), (6, 6, 3, 3), (3, 3, 1, 3)] solution_2 = [(0, 0, 5, 5), (4, 6, 5, 7), (7, 5, 5, 6)] solution_3 = [(5, 3, 4, 2), (6, 2, 6, 3), (4, 2, 5, 1)] solution_4 = [(2, 0, 7, 0), (7, 0, 4, 0), (4, 0, 4, 3)] solution_5 = [(4, 5, 5, 6), (7, 4, 7, 3), (7, 3, 4, 3)] solutions = [solution_1, solution_2, solution_3, solution_4, solution_5] result = \"\" for solution in solutions: for move in solution: result += move_to_input(move[0], move[1], move[2], move[3]) print(result.ljust(60, \"A\"))The correct password is tjtotoqlqlolnisnrospunsoslrktktlrksjpiuiuiririrlrnsoumululrlConclusion I was born in a city where people mostly play chinese chess instead of chess. I have never played chess before until I started solving this crackme. Did I solve this crackme by myself? To be honest I am not. I was stuck for a day because stockfish could not find the solution. Then I pm s4r to ask for hint and he said my parsed chess board is inverted. He also give me a nice link to play with stockfish. After correct the chess board, stockfish was able to checkmate in 3 moves. Here is my first parsed board (match 1).Inverted boardI still don’t know why stockfish can’t checkmate in 3 moves for inverted board although it should be the same." }, { "title": "NahamCon CTF 2023 - Mayhem", "url": "/posts/nahamcon-mayhem-solution/", "categories": "Writeup, Reverse Engineering", "tags": "ctf, reverse engineering, malware, DFIR", "date": "2023-06-17 09:19:00 +0700", "snippet": "Last weekend I spent my free time to play NahamCon CTF with idek team. We managed to get 3rd place and first blood on Mayhem challenge. Here is a quick write up for the challenge.Challenge overview...", "content": "Last weekend I spent my free time to play NahamCon CTF with idek team. We managed to get 3rd place and first blood on Mayhem challenge. Here is a quick write up for the challenge.Challenge overviewThe SOC team noticed a system periodically beaconing to a suspicious IP address. A snapshot of the suspicious process' memory was taken but the IR team wants to know what exactly is going on with this system.The description tell us that there is a process memory dump and we have find a way to extract the flag from it. Also it provide us the diff file.The diff fileWith a few google search, I was able to find out the orginial github repos. For anyone who doesn’t know, Havoc is an open source post-exploitation command and control framework. Because it’s open source, so the reverse engineering task become much more easier.The dump fileEnough with the diff file, let’s look at the dump file. To analyze the dump file, I use windbg preview. Windbg is too old so I should change to windbg preview instead. By enter command !address, windbg preview show us the memory region. BaseAddress EndAddress+1 RegionSize Type State Protect Usage--------------------------------------------------------------------------------------------------------------------------+ 7ff5`fbd91000 7ff5`fbda0000 0`0000f000 MEM_FREE PAGE_NOACCESS Free + 7ff5`fbda0000 7ff5`fbdc3000 0`00023000 MEM_MAPPED MEM_COMMIT PAGE_READONLY Other [NLS Tables]+ 7ff5`fbdc3000 7ff7`96f50000 1`9b18d000 MEM_FREE PAGE_NOACCESS Free + 7ff7`96f50000 7ff7`96f68000 0`00018000 MEM_IMAGE MEM_COMMIT PAGE_READWRITE Image [demon; \"C:\\Users\\lowpriv1\\Downloads\\demon.exe\"]+ 7ff7`96f68000 7ffe`5f5e0000 6`c8678000 MEM_FREE PAGE_NOACCESS Free Cool. Now we know that malware process named demon.exe and allocated at 0x7ff796f50000. But the page protection is weird. PAGE_READWRITE? No execution flag set?. It’s more weird if you view the page with windbg. Totally no PE header and only junk data.This really confused me a bit. After spend some time to dig into demon code, I found a nice feature of demon payload called Ekko.The detection mechanism of Antivirus (optional)This does not releate to the challenge but I want to spend few lines to talk about it. Usually Antivirus have 3 kind of detection Static detection: Based on signature matching. This is easy to bypass. Most malware can bypass this. Emulation detection: Some malware use packer/crypter to hide real payload. The real payload is unpacked during execution. That would fail the static detection but some AVs are able to emulate the code to get the real payload and doing some signature matching. Still a lot of malware can bypass this. Realtime detection: Monitor the malware during execution and terminate it before it execute malicious payload. Only few malware can bypass this.Now what is Ekko? It’s a method to hide malware payload during runtime execution. By using this, demon payload belong to the fews that can hide itself from runtime detection. Ekko works by encrypt the malware payload while it is sleeping. If an AV scan the payload’s memory during its sleeping time (and malware sleep almost of time), it would found nothing in the memory.Getting the decryption key and decrypt the payloadNow we know that the demon payload is encrypted because of Ekko. To decrypt this, we have to find out how does Ekko encrypt the payload. Digging through the code I found something interesting.VOID FoliageObf( PSLEEP_PARAM Param ){ USTRING Key = { 0 }; USTRING Rc4 = { 0 }; UCHAR Random[16] = { 0 }; //....... ImageBase = Instance.Session.ModuleBase; ImageSize = IMAGE_SIZE( Instance.Session.ModuleBase ); // Generate random keys for ( SHORT i = 0; i &lt; 16; i++ ) Random[ i ] = RandomNumber32( ); Key.Buffer = &amp;Random; Key.Length = Key.MaximumLength = 0x10; Rc4.Buffer = ImageBase; Rc4.Length = Rc4.MaximumLength = ImageSize; //.....Payload is encrypted by using RC4. The type of key variable is UString and the key is 16 bytes long. Quickly look at UString structuretypedef struct{ DWORD\tLength; DWORD\tMaximumLength; PVOID\tBuffer;} USTRING ;Now we know that RC4 Key variable should begin with 10 00 00 00 10 00 00 00. Using any hex editor to search in dump file we found 85 results.Choose the result which have Buffer field belong to stack region. Luckily it’s first hit. We found the address of RC4 key is 0xA42C3FD6B0RC4 key is 00 B0 0E 44 60 28 AC B2 E8 5C D0 72 84 44 EC EANow the final step is decrypt the payload. Using command .writemem to dump the payload. .writemem demon_region.exe.mem 0x7ff796f50000 L?0x00018000 Wring the script to decrypt dumped payloadfrom Crypto.Cipher import ARC4if __name__ == \"__main__\": key = bytes.fromhex(\"00 B0 0E 44 60 28 AC B2 E8 5C D0 72 84 44 EC EA\") cipher = ARC4.new(key) f = open(\"demon_region.exe.mem\", \"rb\") enc = f.read() f.close() de = cipher.decrypt(enc) f = open(\"binary.exe\", \"wb\") f.write(de) f.close() Search through decrypted payload and find the flag." }, { "title": "s4r's hvm solution", "url": "/posts/hvm-solution/", "categories": "Writeup, Reverse Engineering", "tags": "crackme, reverse engineering", "date": "2023-06-17 09:19:00 +0700", "snippet": "This is my old solution for s4r’s hvm crackmeAnalyze the crackmeAs the crackme’s description said that it’s a virtual machine (vm) one. Usually I will go quick while talking about reverse engineeri...", "content": "This is my old solution for s4r’s hvm crackmeAnalyze the crackmeAs the crackme’s description said that it’s a virtual machine (vm) one. Usually I will go quick while talking about reverse engineering the vm interpreter and will go into detail about vm ops code, what kind of vm, how does vm work,…. But this crackme worth to talk about the vm interpreter.The way crackme run the vm is very creative. It creates total 5 process with share vm memory. Each process will execute one vm instruction, then random pass the execution of next instruction to another process. By doing this crackme will make sure it run the vm code in 5 different process without changing the vm context. See image bellowAlso the vm decrypt the vm code and vm context each time it start executing vm instruction. After it finish executing instruction, it encrypt vm code and vm context again. The image below show how does crackme encrypt vm code and vm context after finishing execute vm instructionThe encryption is TEA with the keys is {0xCAFEBABE, 0xDEADBEEF, 0xABAD1DEA, 0xB19B00B5}. Keys can be found at the vm initHere is the struct of the vmstruct SVMContext{ int reg[7]; int vmSP; int vmIP; int flags; DWORD teaKey[4]; int bExit;};struct SVM{ DWORD vmMem[786432]; SVMContext vmContext;};Total size of vm struct is 0x301000. The details of vm struct are 0x0 – 0x2FFFFF: vm memory 0x0 – 0xFFFFF: vm code segment 0x100000 – 0x1FFFFF: vm stack segment 0x200000 – 0x2FFFFF: vm data segment 0x30000 – 0x30FFF: vm contextThe vm ops code can be seen at the table below Ops code Instruction 2 jump 11 je 12 add 15 exit 17 sub 12 mov 23 not 24 xor 25 shl 26 mod 27 and 31 or 32 call 33 ret 34 shr 35 cmp 37 get mem 38 pop 42 set mem 54 push 57 jne Here is a sample of add handler (code perform instruction add)Analyze the VMIf the password length is 16, it will be copied to vm memory at offset 0x210000 then run the vm. To analyze the vm, we need to dump the vm memory (which include all necessary data such as password, vm data and vm code) then write a disassembler to analyze it. To dump the vm memory, just debugging it and dump the memory before it execute any vm instruction. You can find my dump here. There are many options to write a dissembler such as using C, python,… but in this case I wrote a small IDA processor to dissamble the vm code.Click here to expand IDA Processor from idc import *from idautils import *from idaapi import *class hvm_processor_t(processor_t):\tid = 0x8000 + 1212\tflag = PR_ASSEMBLE | PRN_HEX \tcnbits = 8\tdnbits = 32\tpsnames = [\"hvm\"]\tplnames = [\"HVM Processor\"]\tsegreg_size = 0\tinstruc_start = 0\t\tassembler = {\t\t\"header\": [\".hvm\"],\t\t\"flag\": AS_NCHRE | ASH_HEXF0 | ASD_DECF0 | ASO_OCTF0 | ASB_BINF0,\t\t\"uflag\": 0,\t\t\"name\": \"hvm assembler\",\t\t\"origin\": \".org\",\t\t\"end\": \".end\",\t\t\"cmnt\": \";\",\t\t\"ascsep\": \"'\",\t\t\"accsep\": \"'\",\t\t\"esccodes\": \"\\\"'\",\t\t\"a_ascii\": \".ascii\",\t\t\"a_byte\": \".byte\",\t\t\"a_word\": \".word\",\t\t\"a_dword\": \".dword\",\t\t\"a_bss\": \"dfs %s\",\t\t\"a_seg\": \"seg\",\t\t\"a_curip\": \"PC\",\t\t\"a_public\": \"\",\t\t\"a_weak\": \"\",\t\t\"a_extrn\": \".extern\",\t\t\"a_comdef\": \"\",\t\t\"a_align\": \".align\",\t\t\"lbrace\": \"(\",\t\t\"rbrace\": \")\",\t\t\"a_mod\": \"%\",\t\t\"a_band\": \"&amp;\",\t\t\"a_bor\": \"|\",\t\t\"a_xor\": \"^\",\t\t\"a_bnot\": \"~\",\t\t\"a_shl\": \"&lt;&lt;\",\t\t\"a_shr\": \"&gt;&gt;\",\t\t\"a_sizeof_fmt\": \"size %s\",\t}\t\t\t# size of a segment register in bytes\tsegreg_size = 0\t\treg_names = [\t 'r0',\t 'r1',\t 'r2',\t 'r3',\t 'r4',\t 'r5',\t 'r6',\t 'sp',\t]\t\t# Array of instructions\tinstruc = [\t\t{'name': 'jmp', 'feature':CF_JUMP | CF_USE1, 'cmt': \"Unconditional jump\"},\t\t{'name': 'je', 'feature':CF_JUMP | CF_USE1, 'cmt': \"Jump if flag set to 1\"},\t\t{'name': 'add', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Add\"},\t\t{'name': 'exit', 'feature':CF_STOP, 'cmt': \"Exit program\"},\t\t{'name': 'sub', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Sub\"},\t\t{'name': 'mov', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Mov\"},\t\t{'name': 'not', 'feature':CF_USE1, 'cmt': \"Not\"},\t\t{'name': 'xor', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Xor\"},\t\t{'name': 'shl', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Shl\"},\t\t{'name': 'mod', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Mod\"},\t\t{'name': 'and', 'feature':CF_USE1 | CF_USE2, 'cmt': \"And\"},\t\t{'name': 'or', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Or\"},\t\t{'name': 'call', 'feature':CF_CALL | CF_USE1, 'cmt': \"Call\"},\t\t{'name': 'ret', 'feature':CF_STOP, 'cmt': \"Ret\"},\t\t{'name': 'shr', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Shr\"},\t\t{'name': 'cmp', 'feature':CF_USE1 | CF_USE2, 'cmt': \"Cmp\"},\t\t#{'name': 'mov', 'feature':0, 'cmt': \"Get memory\"},\t\t{'name': 'pop', 'feature':CF_USE1, 'cmt': \"Pop\"},\t\t#{'name': 'mov', 'feature':0, 'cmt': \"Set memory\"},\t\t{'name': 'push', 'feature':CF_USE1, 'cmt': \"Push register\"},\t\t{'name': 'jne', 'feature':CF_JUMP | CF_USE1, 'cmt': \"Jump if flag set to 0\"},\t]\t\tinstruc_idx = {\t\t'jmp' : 0, \t\t'je' : 1, \t\t'add' : 2,\t\t'exit' : 3, \t\t'sub' : 4, \t\t'mov' : 5,\t\t'not' : 6,\t\t'xor' : 7, \t\t'shl' : 8,\t\t'mod' : 9,\t\t'and' : 10,\t\t'or' : 11,\t\t'call' : 12,\t\t'ret' : 13,\t\t'shr' : 14,\t\t'cmp' : 15,\t\t'pop' : 16,\t\t'push' : 17,\t\t'jne' : 18,\t}\t\t# icode of the first instruction\tinstruc_start = 0\t# icode of the last instruction + 1\tinstruc_end = len(instruc) + 1\t\t# Segment register information (use virtual CS and DS registers if your\t# processor doesn't have segment registers):\treg_first_sreg = 0 # index of CS\treg_last_sreg = 0 # index of DS\t# You should define 2 virtual segment registers for CS and DS.\t# number of CS/DS registers\treg_code_sreg = -1\treg_data_sreg = -1\t\t\t\t\t\tdef get_reg(self, op):\t\treturn (op &gt;&gt; 5) &amp; 7\t\t\tdef get_value(self, ea, op_cmd):\t\tif (get_wide_byte(ea + 1) &amp; 1 != 0):\t\t\top_cmd.type = o_imm\t\t\top_cmd.value = get_wide_dword(ea + 2)\t\t\top_cmd.addr = get_wide_dword(ea + 2)\t\telse:\t\t\top_cmd.type = o_reg\t\t\top_cmd.reg = (get_wide_byte(ea + 1) &gt;&gt; 2) &amp; 7\t\treturn True\t\t\tdef get_mem(self, ea, op_cmd):\t\tif (get_wide_byte(ea + 1) &amp; 1 != 0):\t\t\top_cmd.type = o_phrase #address memory\t\t\top_cmd.value = get_wide_dword(ea + 2)\t\t\top_cmd.addr = get_wide_dword(ea + 2)\t\telse:\t\t\top_cmd.type = o_displ #reg memory\t\t\top_cmd.reg = (get_wide_byte(ea + 1) &gt;&gt; 2) &amp; 7\t\treturn True\t\t\tdef get_instruction_itype(self, name):\t\tret = self.instruc_idx.get(name) \t\tif ret is not None:\t\t\treturn ret\t\telse:\t\t\tprint(\"Could not find instruction %s\" % name)\t\t\treturn -1\tdef get_instruction_name(self, itype):\t\tfor i, ins in enumerate(self.instruc):\t\t\tif i == itype:\t\t\t\treturn ins['name']\t\t\t\t\t\tdef notify_func_bounds(self, code, func_ea, max_func_end_ea):\t\treturn FIND_FUNC_OK\tdef notify_out_operand(self, ctx, op):\t\tif op.type == o_imm:\t\t\tctx.out_value(op, OOFW_32)\t\telif op.type == o_near:\t\t\tctx.out_name_expr(op, op.addr)\t\telif op.type == o_phrase:\t\t\tctx.out_symbol(\"[\")\t\t\tctx.out_name_expr(op, op.addr)\t\t\tctx.out_symbol(\"]\")\t\telif op.type == o_displ:\t\t\tctx.out_symbol(\"[\")\t\t\tctx.out_register(self.reg_names[op.reg])\t\t\tctx.out_symbol(\"]\")\t\telif op.type == o_reg:\t\t\tctx.out_register(self.reg_names[op.reg])\t\telse:\t\t\treturn False\t\treturn True\t\t\t\tdef notify_out_insn(self, ctx):\t\tctx.out_line(self.get_instruction_name(ctx.insn.itype))\t\t\t\tfeature = ctx.insn.get_canon_feature()\t\t\t\tctx.out_spaces(5)\t\t\t\tif feature &amp; CF_USE1:\t\t\tctx.out_one_operand(0)\t\t\t\tif feature &amp; CF_USE2:\t\t\tctx.out_char(\",\")\t\t\tctx.out_char(\" \")\t\t\tctx.out_one_operand(1)\t\tctx.flush_outbuf()\t\treturn\t\t\t\tdef notify_emu(self, cmd):\t\tfeature = cmd.get_canon_feature()\t\t#Analyze instruction to make ref\t\tif self.instruc[cmd.itype]['name'] in ('je', 'jne'):\t\t\tif cmd[0].addr != 0 and cmd[0].type != o_reg:\t\t\t\tadd_cref(cmd.ea, cmd[0].addr, fl_JN)\t\t\tflows = (feature &amp; CF_STOP) == 0\t\t\tif flows:\t\t\t\tadd_cref(cmd.ea, cmd.ea + cmd.size, fl_F)\t\telif self.instruc[cmd.itype]['name'] == 'call':\t\t\tif cmd[0].addr != 0:\t\t\t\tadd_cref(cmd.ea, cmd[0].addr, fl_CN)\t\t\tflows = (feature &amp; CF_STOP) == 0\t\t\tif flows:\t\t\t\tadd_cref(cmd.ea, cmd.ea + cmd.size, fl_F)\t\telif self.instruc[cmd.itype]['name'] == 'jmp':\t\t\tif cmd[0].addr != 0 and cmd[0].type != o_reg:\t\t\t\tadd_cref(cmd.ea, cmd[0].addr, fl_JN)\t\telse:\t\t\tflows = (feature &amp; CF_STOP) == 0\t\t\tif flows:\t\t\t\tadd_cref(cmd.ea, cmd.ea + cmd.size, fl_F)\t\t\t\t\t\treturn True\tdef notify_ana(self, cmd):\t\toptype = get_wide_byte(cmd.ea)\t\t\t\tif optype == 2: #jump\t\t\tcmd.itype = self.get_instruction_itype('jmp')\t\t\tcmd.size = 6\t\t\tself.get_value(cmd.ea, cmd[0])\t\t\tif cmd[0].type == o_imm:\t\t\t\tcmd[0].type = o_near\t\telif optype == 11: #je\t\t\tcmd.itype = self.get_instruction_itype('je')\t\t\tcmd.size = 6\t\t\tself.get_value(cmd.ea, cmd[0])\t\t\tif cmd[0].type == o_imm:\t\t\t\tcmd[0].type = o_near\t\telif optype == 12: #Add register\t\t\tcmd.itype = self.get_instruction_itype('add')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 15: #Exit\t\t\tcmd.itype = self.get_instruction_itype('exit')\t\t\tcmd.size = 6\t\telif optype == 17: #Sub\t\t\tcmd.itype = self.get_instruction_itype('sub')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 22: #mov reg, value\t\t\tcmd.itype = self.get_instruction_itype('mov')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 23: #not\t\t\tcmd.itype = self.get_instruction_itype('not')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 24: #xor\t\t\tcmd.itype = self.get_instruction_itype('xor')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 25: #shl\t\t\tcmd.itype = self.get_instruction_itype('shl')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 26: #mod\t\t\tcmd.itype = self.get_instruction_itype('mod')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 27: #and\t\t\tcmd.itype = self.get_instruction_itype('and')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 31: #or\t\t\tcmd.itype = self.get_instruction_itype('or')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 32: #call\t\t\tcmd.itype = self.get_instruction_itype('call')\t\t\tcmd.size = 6\t\t\tself.get_value(cmd.ea, cmd[0])\t\t\tif cmd[0].type == o_imm:\t\t\t\tcmd[0].type = o_near\t\telif optype == 33: #ret\t\t\tcmd.itype = self.get_instruction_itype('ret')\t\t\tcmd.size = 6\t\telif optype == 34: #shr\t\t\tcmd.itype = self.get_instruction_itype('shr')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 35: #cmp\t\t\tcmd.itype = self.get_instruction_itype('cmp')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_value(cmd.ea, cmd[1])\t\telif optype == 37: #Get mem\t\t\tcmd.itype = self.get_instruction_itype('mov')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\tself.get_mem(cmd.ea, cmd[1])\t\telif optype == 38: #pop reg\t\t\tcmd.itype = self.get_instruction_itype('pop')\t\t\tcmd.size = 6\t\t\tcmd[0].type = o_reg\t\t\tcmd[0].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\telif optype == 42: #set mem\t\t\t#This is going to be weird to implement\t\t\tcmd.itype = self.get_instruction_itype('mov')\t\t\tcmd.size = 6\t\t\tself.get_mem(cmd.ea, cmd[0])\t\t\tcmd[1].type = o_reg\t\t\tcmd[1].reg = self.get_reg(get_wide_byte(cmd.ea + 1))\t\t\t#swap reg and value\t\t\tcmd[0].reg, cmd[1].reg = cmd[1].reg, cmd[0].reg\t\t\tcmd[0].value, cmd[1].value = cmd[1].value, cmd[0].value\t\t\tcmd[0].addr, cmd[1].addr = cmd[1].addr, cmd[0].addr\t\telif optype == 54: #push\t\t\tcmd.itype = self.get_instruction_itype('push')\t\t\tcmd.size = 6\t\t\tself.get_value(cmd.ea, cmd[0])\t\telif optype == 57: #jne\t\t\tcmd.itype = self.get_instruction_itype('jne')\t\t\tcmd.size = 6\t\t\tself.get_value(cmd.ea, cmd[0])\t\t\tif cmd[0].type == o_imm:\t\t\t\tcmd[0].type = o_near\t\telse:\t\t\tprint(\"Unknown instruction %X\" % optype)\t\treturn cmd.size\tdef PROCESSOR_ENTRY():\treturn hvm_processor_t() But wait, it doesn’t disasamble the code correctly.That’s because the vm code is still encrypted by TEA. I wrote a small script to decrypt the vm code.Click here to expand decrypting script from idaapi import *import base64import ctypesimport itertoolsimport mathimport structimport hexdump#TEA decryption was taken from https://gist.github.com/twheys/4e83567942172f8ba85058fae6bfeef5def _chunks(iterable, n): it = iter(iterable) while True: chunk = tuple(itertools.islice(it, n)) if not chunk: return yield chunk def _str2vec(value, l=4): n = len(value) # Split the string into chunks num_chunks = math.ceil(n / l) chunks = [value[l * i:l * (i + 1)] for i in range(num_chunks)] return [sum([character &lt;&lt; 8 * j for j, character in enumerate(chunk)]) for chunk in chunks] def _vec2str(vector, l=4): #Modified to work ret = b\"\" for e in vector: ret += struct.pack(\"I\", e) return ret def decrypt(ciphertext, key): #Modified to work if not ciphertext: return '' k = _str2vec(key[:16]) v = _str2vec(ciphertext) return b''.join(_vec2str(_decipher(chunk, k)) for chunk in _chunks(v, 2)) def _decipher(v, k): y, z = [ctypes.c_uint32(x) for x in v] sum = ctypes.c_uint32(0xC6EF3720) delta = 0x9E3779B9 for n in range(32, 0, -1): z.value -= (y.value &lt;&lt; 4) + k[2] ^ y.value + sum.value ^ (y.value &gt;&gt; 5) + k[3] y.value -= (z.value &lt;&lt; 4) + k[0] ^ z.value + sum.value ^ (z.value &gt;&gt; 5) + k[1] sum.value -= delta return [y.value, z.value]if __name__ == \"__main__\": data = get_bytes(0, 0xC70) key = struct.pack(\"IIII\", 0xCAFEBABE, 0xDEADBEEF, 0xABAD1DEA, 0xB19B00B5) decoded_data = decrypt(data, key) hexdump.hexdump(decoded_data) patch_bytes(0, decoded_data) The result is very satisfying.IDA even give us a beautiful graphAlmost done. There is still one thing: The obfuscation with add instruction as you can see in the image. I also wrote a small script to solve this little problemClick here to expand helper script from idc import *from idautils import *from idaapi import *reg_names = [ 'r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'sp', ] def comment_add(): for func_ea in Functions(0, 0x0C66): for (start_ea, end_ea) in Chunks(func_ea): sum = 0 reg = -1 for head in Heads(start_ea, end_ea): insn = DecodeInstruction(head) if insn.itype == 2 and insn.Op1.type == o_reg and insn.Op2.type == o_imm: if reg == -1: reg = insn.Op1.reg sum = (sum + insn.Op2.value) &amp; 0xFFFFFFFF else: if insn.Op1.reg == reg: sum = (sum + insn.Op2.value) &amp; 0xFFFFFFFF else: sum = 0 reg = -1 else: if reg != -1: cmt_addr = idc.prev_head(head) set_cmt(cmt_addr, \"add %s, %Xh\" % (reg_names[reg], sum), 0) sum = 0 reg = -1 return if __name__ == \"__main__\": comment_add() The script does the simple thing: Add the comment. The result is much more betterNow with the help of IDA, reverse engineering the vm become easier. Here is the rewritten of password checking algo (not exactly the same but at least it show how does the vm code run)Click here to expand rewritten of password checking algo #include &lt;stdio.h&gt;#include &lt;string.h&gt;const char plain1[] = \"Who controls the past controls the future. Who controls the present controls the past.\";const char plain2[] = \"We know that no one ever seizes power with the intention of relinquishing it.\";const char plain3[] = \"Freedom is the freedom to say that two plus two make four. If that is granted, all else follows.\";const char plain4[] = \"Perhaps one did not want to be loved so much as to be understood.\";const unsigned char enc1[] = { 0xAD, 0x44, 0x40, 0xC8, 0xDA, 0x68, 0xE2, 0x80, 0x64, 0xC4, 0x33, 0xA3, 0xEF, 0xA2, 0x8C, 0x51, 0x6A, 0x03, 0xFF, 0xDA, 0x7E, 0xC3, 0x18, 0x7B, 0x98, 0xCD, 0x75, 0x0D, 0x7A, 0xFB, 0x95, 0x25, 0x85, 0x7E, 0x7C, 0x5E, 0x71, 0xB2, 0xB7, 0xDE, 0x04, 0x59, 0xD8, 0xA9, 0x8D, 0xF8, 0x12, 0xBC, 0xB9, 0x8F, 0xB8, 0x41, 0xE6, 0x58, 0xB4, 0x05, 0x1D, 0xA9, 0xD7, 0x88, 0x43, 0xE7, 0xB6, 0x0C, 0xF1, 0x2B, 0x0B, 0x0E, 0x5C, 0x82, 0xC2, 0xAC, 0xF4, 0x2F, 0xC9, 0x5E, 0x9F, 0x9B, 0x83, 0xD7, 0x93, 0xCA, 0xB0, 0x89, 0x16, 0x8B};const unsigned char enc2[] = { 0x0A, 0xE5, 0xC7, 0x63, 0xE2, 0xB2, 0x1D, 0xB8, 0x9A, 0x03, 0x5D, 0xC5, 0xFC, 0xB1, 0x05, 0x6C, 0xA4, 0x7F, 0x02, 0x9C, 0xB0, 0xA7, 0x02, 0xAC, 0x6C, 0x50, 0x3A, 0x6D, 0xA2, 0xE0, 0x70, 0x38, 0x84, 0x61, 0xB4, 0xE3, 0x27, 0xE5, 0x56, 0xFC, 0x65, 0x9F, 0x28, 0x6C, 0x62, 0x3A, 0x70, 0xF8, 0x02, 0x73, 0x44, 0x2C, 0xDD, 0xC1, 0xA4, 0xB4, 0x9E, 0x24, 0x3B, 0xB9, 0xD5, 0xD4, 0xF0, 0x6D, 0xC0, 0x44, 0x22, 0x61, 0x8E, 0x66, 0x43, 0x62, 0x1E, 0x6C, 0x13, 0xAA, 0x87};const unsigned char enc3[] = { 0xAA, 0x84, 0xD7, 0x8F, 0xC8, 0xC2, 0xE3, 0x62, 0xC0, 0x9C, 0xFB, 0x64, 0x9E, 0x9E, 0xA3, 0x2A, 0x0B, 0xFB, 0x62, 0xC6, 0xC9, 0x66, 0x5C, 0xEC, 0xF5, 0x43, 0x3D, 0x16, 0x65, 0xA1, 0x80, 0xE0, 0x57, 0x99, 0x4C, 0xFE, 0x58, 0xF2, 0xA0, 0xC3, 0xC8, 0xCE, 0x1C, 0x2A, 0x63, 0x57, 0x59, 0xAE, 0xFC, 0xE3, 0x77, 0xB4, 0xAC, 0x9C, 0xA1, 0x17, 0xC5, 0x7B, 0x37, 0x9D, 0x94, 0x70, 0x40, 0x9B, 0x37, 0x52, 0x1D, 0xF1, 0xF5, 0xDB, 0xB2, 0x57, 0x82, 0xAB, 0xC8, 0x21, 0x38, 0xA8, 0x24, 0x73, 0x9A, 0xF4, 0xC5, 0x13, 0xF7, 0xF3, 0xAA, 0x32, 0xCC, 0xD1, 0xB2, 0x00, 0xE1, 0xF4, 0x5D, 0xC5};const unsigned char enc4[] = { 0x28, 0x52, 0x7F, 0x52, 0xB3, 0xE9, 0xF1, 0x12, 0xBC, 0x11, 0x41, 0xF9, 0x0A, 0xC5, 0x94, 0x70, 0x6E, 0x3C, 0x0D, 0x4E, 0xE3, 0xCB, 0x57, 0x8C, 0x35, 0x8E, 0xF6, 0x21, 0x4D, 0x6C, 0x7A, 0x01, 0x17, 0xC6, 0x93, 0x89, 0x54, 0x5A, 0x2E, 0xE0, 0xE8, 0x23, 0xE4, 0x12, 0x8E, 0xAF, 0x50, 0x89, 0xC9, 0xD7, 0x4B, 0x87, 0xE5, 0xEC, 0x78, 0x0E, 0xD5, 0xBC, 0x05, 0x30, 0xDB, 0x0D, 0x0C, 0x4A, 0xA6};const char* plain_array[] = { plain1, plain2, plain3, plain4 };const unsigned char* enc_array[] = { enc1, enc2, enc3, enc4 };const size_t size_array[] = { sizeof(plain1) - 1, sizeof(plain2) - 1, sizeof(plain3) - 1, sizeof(plain4) - 1 };int rc4(const void* inbuf, void* outbuf, size_t buflen, const char* key, size_t keylen);bool check_password(char* password){\tint result = false;\tunsigned char tmp[255];\tfor (int i = 0; i &lt; 4; i++)\t{\t\trc4(plain_array[i], tmp, size_array[i], &amp;password[i * 4], 4);\t\tresult |= (memcmp(enc_array[i], tmp, size_array[i]) != 0)\t}\treturn (result == false)}int main(){\tchar password[16];\tif (check_password(password))\t\tprintf(\"correct\");\telse\t\tprintf(\"wrong\");} Sar did a good job. He implemented whole rc4 algo in vm code. Here is a few tips to know it’s rc4: There is a loop to fill an array with value from 0 to 255 There is code does swap to variablesGetting the correct passwordNow we know the vm algo. Here is the C++ code to brute force passwordClick here to expand solution program #include &lt;stdio.h&gt;#include &lt;string.h&gt;const char plain1[] = \"Who controls the past controls the future. Who controls the present controls the past.\";const char plain2[] = \"We know that no one ever seizes power with the intention of relinquishing it.\";const char plain3[] = \"Freedom is the freedom to say that two plus two make four. If that is granted, all else follows.\";const char plain4[] = \"Perhaps one did not want to be loved so much as to be understood.\";const unsigned char enc1[] = { 0xAD, 0x44, 0x40, 0xC8, 0xDA, 0x68, 0xE2, 0x80, 0x64, 0xC4, 0x33, 0xA3, 0xEF, 0xA2, 0x8C, 0x51, 0x6A, 0x03, 0xFF, 0xDA, 0x7E, 0xC3, 0x18, 0x7B, 0x98, 0xCD, 0x75, 0x0D, 0x7A, 0xFB, 0x95, 0x25, 0x85, 0x7E, 0x7C, 0x5E, 0x71, 0xB2, 0xB7, 0xDE, 0x04, 0x59, 0xD8, 0xA9, 0x8D, 0xF8, 0x12, 0xBC, 0xB9, 0x8F, 0xB8, 0x41, 0xE6, 0x58, 0xB4, 0x05, 0x1D, 0xA9, 0xD7, 0x88, 0x43, 0xE7, 0xB6, 0x0C, 0xF1, 0x2B, 0x0B, 0x0E, 0x5C, 0x82, 0xC2, 0xAC, 0xF4, 0x2F, 0xC9, 0x5E, 0x9F, 0x9B, 0x83, 0xD7, 0x93, 0xCA, 0xB0, 0x89, 0x16, 0x8B};const unsigned char enc2[] = { 0x0A, 0xE5, 0xC7, 0x63, 0xE2, 0xB2, 0x1D, 0xB8, 0x9A, 0x03, 0x5D, 0xC5, 0xFC, 0xB1, 0x05, 0x6C, 0xA4, 0x7F, 0x02, 0x9C, 0xB0, 0xA7, 0x02, 0xAC, 0x6C, 0x50, 0x3A, 0x6D, 0xA2, 0xE0, 0x70, 0x38, 0x84, 0x61, 0xB4, 0xE3, 0x27, 0xE5, 0x56, 0xFC, 0x65, 0x9F, 0x28, 0x6C, 0x62, 0x3A, 0x70, 0xF8, 0x02, 0x73, 0x44, 0x2C, 0xDD, 0xC1, 0xA4, 0xB4, 0x9E, 0x24, 0x3B, 0xB9, 0xD5, 0xD4, 0xF0, 0x6D, 0xC0, 0x44, 0x22, 0x61, 0x8E, 0x66, 0x43, 0x62, 0x1E, 0x6C, 0x13, 0xAA, 0x87};const unsigned char enc3[] = { 0xAA, 0x84, 0xD7, 0x8F, 0xC8, 0xC2, 0xE3, 0x62, 0xC0, 0x9C, 0xFB, 0x64, 0x9E, 0x9E, 0xA3, 0x2A, 0x0B, 0xFB, 0x62, 0xC6, 0xC9, 0x66, 0x5C, 0xEC, 0xF5, 0x43, 0x3D, 0x16, 0x65, 0xA1, 0x80, 0xE0, 0x57, 0x99, 0x4C, 0xFE, 0x58, 0xF2, 0xA0, 0xC3, 0xC8, 0xCE, 0x1C, 0x2A, 0x63, 0x57, 0x59, 0xAE, 0xFC, 0xE3, 0x77, 0xB4, 0xAC, 0x9C, 0xA1, 0x17, 0xC5, 0x7B, 0x37, 0x9D, 0x94, 0x70, 0x40, 0x9B, 0x37, 0x52, 0x1D, 0xF1, 0xF5, 0xDB, 0xB2, 0x57, 0x82, 0xAB, 0xC8, 0x21, 0x38, 0xA8, 0x24, 0x73, 0x9A, 0xF4, 0xC5, 0x13, 0xF7, 0xF3, 0xAA, 0x32, 0xCC, 0xD1, 0xB2, 0x00, 0xE1, 0xF4, 0x5D, 0xC5};const unsigned char enc4[] = { 0x28, 0x52, 0x7F, 0x52, 0xB3, 0xE9, 0xF1, 0x12, 0xBC, 0x11, 0x41, 0xF9, 0x0A, 0xC5, 0x94, 0x70, 0x6E, 0x3C, 0x0D, 0x4E, 0xE3, 0xCB, 0x57, 0x8C, 0x35, 0x8E, 0xF6, 0x21, 0x4D, 0x6C, 0x7A, 0x01, 0x17, 0xC6, 0x93, 0x89, 0x54, 0x5A, 0x2E, 0xE0, 0xE8, 0x23, 0xE4, 0x12, 0x8E, 0xAF, 0x50, 0x89, 0xC9, 0xD7, 0x4B, 0x87, 0xE5, 0xEC, 0x78, 0x0E, 0xD5, 0xBC, 0x05, 0x30, 0xDB, 0x0D, 0x0C, 0x4A, 0xA6};const char* plain_array[] = { plain1, plain2, plain3, plain4 };const unsigned char* enc_array[] = { enc1, enc2, enc3, enc4 };const size_t size_array[] = { sizeof(plain1) - 1, sizeof(plain2) - 1, sizeof(plain3) - 1, sizeof(plain4) - 1 };int rc4_x86(const void* inbuf, void* outbuf, size_t buflen, const char* key, size_t keylen);//brb{Rc4_in_4_vM}int main(){\tchar key[4];\tchar password[] = \"????????????????\";\tunsigned char tmp[200];\tint found_cnt = 0;\tfor (int char1 = 0x20; char1 &lt;= 0x7E; char1++)\t{\t\tkey[0] = char1;\t\tfor (int char2 = 0x20; char2 &lt;= 0x7E; char2++)\t\t{\t\t\tkey[1] = char2;\t\t\tfor (int char3 = 0x20; char3 &lt;= 0x7E; char3++)\t\t\t{\t\t\t\tkey[2] = char3;\t\t\t\tfor (int char4 = 0x20; char4 &lt;= 0x7E; char4++)\t\t\t\t{\t\t\t\t\tkey[3] = char4;\t\t\t\t\tfor (int i = 0; i &lt; 4; i++)\t\t\t\t\t{\t\t\t\t\t\trc4_x86(plain_array[i], tmp, size_array[i], key, 4);\t\t\t\t\t\tif (memcmp(enc_array[i], tmp, size_array[i]) == 0)\t\t\t\t\t\t{\t\t\t\t\t\t\t*(unsigned int*)&amp;password[i * 4] = *(unsigned int*)key;\t\t\t\t\t\t\tfound_cnt++;\t\t\t\t\t\t\tprintf(\"%s\\n\", password);\t\t\t\t\t\t\tif (found_cnt == 4)\t\t\t\t\t\t\t\tgoto exit;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}\tif (found_cnt != 4)\t\tprintf(\"Nothing found :(\\n\");exit: return 0;}int rc4_x86(const void* inbuf, void* outbuf, size_t buflen, const char* key, size_t keylen){\tchar s[256];\tchar* s_ptr = s;\tchar k[256];\tchar* k_ptr = k;\tif (buflen &lt;= 0)\t\treturn -1;\t__asm {\t\tmov eax, s_ptr\t\tmov ecx, 256\tfill_s:\t\txor ebx, ebx\t\tsub bl, cl\t\tmov[eax + ebx], bl\t\tloop fill_s\t}\t// Generate k\t__asm {\t\tmov edx, key\t\tmov edi, keylen;//edi = size of key\t\tmov esi, k_ptr;//esi= k;\t\tmov ecx, 256\t\txor ebx, ebx;//ebx=j\tloop_j:\t\tcmp ebx, edi\t\tjl continue_loop\t\txor ebx, ebx;// clear ebx, move to the start of key, repeat until k is full\tcontinue_loop:\t\tmov ah, [edx + ebx]\t\tmov[esi], ah\t\tinc esi\t\tinc ebx\t\tloop loop_j\t}\t// Generate s\t__asm {\t\tmov edi, s_ptr\t\txor ebx, ebx\t\tsub esi, 256\t\txor eax, eax\t\tmov ecx, 256\tloop_s:\t\tmov dl, [esi + eax]\t\tadd bl, dl\t\tmov dl, [edi + eax]\t\tadd bl, dl\t\tmov dl, [edi + eax]\t\tmov dh, [edi + ebx]\t\tmov[edi + eax], dh\t\tmov[edi + ebx], dl\t\tinc eax\t\tloop loop_s\t}\t__asm {\t\tmov esi, inbuf;// esi = inbuf\t\tmov edi, s_ptr;// edi = s\t\tmov edx, outbuf;// edx = outbuf\t\t;// clear registers\t\txor eax, eax\t\txor ebx, ebx\t\tmov ecx, buflen;//ecx = buflen\tcd:\t\tpush ecx\t\tmovzx ecx, al\t\tinc cl\t\tpush edx\t\tmov dh, [edi + ecx]\t\tadd bl, dh\t\tmov dl, [edi + ebx]\t\tmov[edi + ecx], dl\t\tmov[edi + ebx], dh\t\tadd dl, dh\t\tmovzx edx, dl\t\tmov dl, [edi + edx]\t\tmov cl, [esi + eax]\t\txor cl, dl\t\tpop edx\t\tmov[edx + eax], cl\t\tinc eax\t\tpop ecx\t\tloop cd\t}\treturn buflen;} To compile it, you need visual studio (I’m a guy using Windows. Don’t blame me). After about 10 minutes, the brute force code give me the correct password is brb{Rc4_in_4_vM}" } ]
