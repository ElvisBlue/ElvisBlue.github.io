---
title: UIUCTF 2023 - vmwhere1, vmwhere2 and Fast Caculator
date: 2023-07-05 09:00:00 +0700
categories: [Writeup, Reverse Engineering]
tags: [ctf, reverse engineering, vm]
image:
  path: /commons/2023-07-05-uiuctf-2023/img0.PNG
---

Last weekend I spent my free time to play UIUCTF with idek team. We managed to get 18th place (I think we should try harder). During the CTF I solved vmwhere1, vmwhere2 and fast calculator. Here is quick write up for 3 challenges

## vmwhere1

### Challenge overview
![Image](/commons/2023-07-05-uiuctf-2023/img1.PNG)  
The challenge is an ELF file (chal) and a binary file (program). As the challenge name suggest we might have to deal with Virtual Machine challenge.  
[Download](https://github.com/sigpwny/UIUCTF-2023-Public/tree/main/challenges/rev/vmwhere1/challenge)
  
### Reverse engineering
The decompiled code of main look like this (after rename some variable and function)
```c
__int64 __fastcall main(int argc, char **argv, char **a3)
{
  unsigned int program_size; // [rsp+18h] [rbp-18h] BYREF
  __int64 program; // [rsp+20h] [rbp-10h]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  if ( argc > 1 )
  {
    program = load_program(argv[1], &program_size);
    if ( program )
    {
      if ( (unsigned int)run_program(program, program_size) )
        return 3LL;
      else
        return 0LL;
    }
    else
    {
      printf("Failed to read program %s\n", argv[1]);
      return 2LL;
    }
  }
  else
  {
    printf("Usage: %s <program>\n", *argv);
    return 1LL;
  }
}
```

The code of main is pretty simple. The logical of the challenge is in the `run_program` function. Here is the decompiled code (after renamed)
```c
__int64 __fastcall run_program(BYTE *vm_ops_base, int vm_size)
{
  BYTE *curr_ops; // rax
  __int64 result; // rax
  BYTE *ptr; // rax
  BYTE *v5; // rax
  BYTE v6; // [rsp+12h] [rbp-1Eh]
  BYTE v7; // [rsp+13h] [rbp-1Dh]
  int i; // [rsp+14h] [rbp-1Ch]
  BYTE *program_counter; // [rsp+18h] [rbp-18h]
  BYTE *curr_stack; // [rsp+20h] [rbp-10h]
  BYTE *curr_stacka; // [rsp+20h] [rbp-10h]
  BYTE *curr_stackb; // [rsp+20h] [rbp-10h]
  BYTE *curr_stackc; // [rsp+20h] [rbp-10h]
  BYTE *curr_stackd; // [rsp+20h] [rbp-10h]
  BYTE *curr_stacke; // [rsp+20h] [rbp-10h]
  BYTE *stack_base; // [rsp+28h] [rbp-8h]

  program_counter = vm_ops_base;
  stack_base = (BYTE *)malloc(0x1000uLL);
  curr_stack = stack_base;
  while ( 2 )
  {
    if ( vm_ops_base <= program_counter && program_counter < &vm_ops_base[vm_size] )
    {
      curr_ops = program_counter++;
      switch ( *curr_ops )
      {
        case 0u:
          return 0LL;
        case 1u:
          curr_stacka = curr_stack - 2;
          *curr_stacka += curr_stacka[1];
          curr_stack = curr_stacka + 1;
          goto stack_check;
        case 2u:
          curr_stackb = curr_stack - 2;
          *curr_stackb -= curr_stackb[1];
          curr_stack = curr_stackb + 1;
          goto stack_check;
        case 3u:
          curr_stackc = curr_stack - 2;
          *curr_stackc &= curr_stackc[1];
          curr_stack = curr_stackc + 1;
          goto stack_check;
        case 4u:
          curr_stackd = curr_stack - 2;
          *curr_stackd |= curr_stackd[1];
          curr_stack = curr_stackd + 1;
          goto stack_check;
        case 5u:
          curr_stacke = curr_stack - 2;
          *curr_stacke ^= curr_stacke[1];
          curr_stack = curr_stacke + 1;
          goto stack_check;
        case 6u:
          *(curr_stack - 2) <<= *(curr_stack - 1);
          --curr_stack;
          goto stack_check;
        case 7u:
          *(curr_stack - 2) = (int)*(curr_stack - 2) >> *(curr_stack - 1);
          --curr_stack;
          goto stack_check;
        case 8u:
          *curr_stack++ = getchar();
          goto stack_check;
        case 9u:
          putchar(*--curr_stack);
          goto stack_check;
        case 10u:
          ptr = program_counter++;
          *curr_stack++ = *ptr;
          goto stack_check;
        case 11u:
          if ( (*(curr_stack - 1) & 0x80u) != 0 )
            program_counter += (__int16)_byteswap_ushort(*(_WORD *)program_counter);
          program_counter += 2;
          goto stack_check;
        case 12u:
          if ( !*(curr_stack - 1) )
            program_counter += (__int16)_byteswap_ushort(*(_WORD *)program_counter);
          program_counter += 2;
          goto stack_check;
        case 13u:
          program_counter += (__int16)_byteswap_ushort(*(_WORD *)program_counter) + 2;
          goto stack_check;
        case 14u:
          --curr_stack;
          goto stack_check;
        case 15u:
          *curr_stack = *(curr_stack - 1);
          ++curr_stack;
          goto stack_check;
        case 16u:
          v5 = program_counter++;
          v6 = *v5;
          if ( *v5 > curr_stack - stack_base )
            printf("Stack underflow in reverse at 0x%04lx\n", program_counter - vm_ops_base);
          for ( i = 0; i < v6 >> 1; ++i )
          {
            v7 = curr_stack[i - v6];
            curr_stack[i - v6] = curr_stack[~i];
            curr_stack[~i] = v7;
          }
          goto stack_check;
        case 40u:
          vm_debug((__int64)vm_ops_base, (__int64)stack_base, (__int64)curr_stack, program_counter - vm_ops_base);
stack_check:
          if ( curr_stack < stack_base )
          {
            printf("Stack underflow at 0x%04lx\n", program_counter - vm_ops_base);
            return 1LL;
          }
          if ( curr_stack <= stack_base + 4096 )
            continue;
          printf("Stack overflow at 0x%04lx\n", program_counter - vm_ops_base);
          result = 1LL;
          break;
        default:
          printf("Unknown opcode: 0x%02x at 0x%04lx\n", *(program_counter - 1), program_counter - 1 - vm_ops_base);
          return 1LL;
      }
    }
    else
    {
      printf("Program terminated unexpectedly. Last instruction: 0x%04lx\n", program_counter - vm_ops_base);
      return 1LL;
    }
    return result;
  }
}
```
Reading and understand the code show me that this is a [stack base](https://en.wikipedia.org/wiki/Stack_machine) virtual machine. Here is the ops code table with description.

| Ops code    | Instruction      | Description                                                                |
|:------------|:-----------------|:---------------------------------------------------------------------------|
| 0           | halt             | Exit the VM                                                                |
| 1           | add              | Stack: [a, b,...] -> [a + b,...]                                           |
| 2           | sub              | Stack: [a, b,...] -> [a - b,...]                                           |
| 3           | and              | Stack: [a, b,...] -> [a & b,...]                                           |
| 4           | or               | Stack: [a, b,...] -> [a or b,...]                                          |
| 5           | xor              | Stack: [a, b,...] -> [a ^ b,...]                                           |
| 6           | shl              | Stack: [a, b,...] -> [b << a,...]                                          |
| 7           | shr              | Stack: [a, b,...] -> [b >> a,...]                                          |
| 8           | getchar          | Get a char and push to stack                                               |
| 9           | putchar          | Pop value from stack and print it                                          |
| 10          | push const       | Push a const to stack                                                      |
| 11          | jnz?             | Jump if bit 8th of first value on the stack is 1                           |
| 12          | jz               | Jump if first value on the stack is 0                                      |
| 13          | jmp              | Jump to address                                                            |
| 14          | drop             | Stack: [a, b,...] -> [b,...]                                               |
| 15          | dup              | Stack: [a, b,...] -> [a, b, b,...]                                         |
| 16          | nrot             | Pop N values from the stack, and rotates top N values on the stack         |
| 40          | debug            | Print VM debug information                                                 |


There are two methods I usually use to solve VM challenge
- Writing a VM disassembler
- Writing a VM emulator so that I can attach a log engine or even a debugger engine.

### Binary Ninja Arch plugin
My favorite method to solve VM challenge is writing a disassembler. During the challenge I wrote a disassembler for the virtual machine in python. But in this writeup I want to show you a cool way to defeat a VM: Writing a binary ninja arch plugin. So why binary ninja? Even IDA has a same feature called IDA processor module but I find out that binary ninja plugin is easier to write and look cool. [Here](https://binary.ninja/2020/01/08/guide-to-architecture-plugins-part1.html) is an offical tut how to write an arch plugin. You can also look at some example [here](https://github.com/thisusernameistaken?tab=repositories). Here is the one I wrote for vmwhere1 and vmwhere2

```python
from binaryninja.architecture import Architecture
from binaryninja.log import log_info
from binaryninja.function import RegisterInfo, InstructionInfo, InstructionTextToken
from binaryninja.enums import InstructionTextTokenType, BranchType
import ctypes

class CVMWhere(Architecture):
    name = "vmwhere"
    address_size = 8		# 8-bit addresses
    default_int_size = 1	# 1-byte integers
    instr_alignment = 1		# no instruction alignment
    max_instr_length = 3	# maximum length
    
    def get_instruction_info(self, data, addr):
        #Get instruction size
        result = InstructionInfo()
        if data[0] in [10]:
            result.length = 2
        elif data[0] in [11, 12, 13]:
            result.length = 3
        else:
            result.length = 1
        
        #Get instruction branch
        if data[0] == 0:
            result.add_branch(BranchType.FunctionReturn)
        elif data[0] in [11, 12, 13]:
            range = ctypes.c_short((data[1] << 8) | data[2]).value + 3
            
            #We got jmp
            if data[0] == 13:
                result.add_branch(BranchType.UnconditionalBranch, addr + range)
            else:
                result.add_branch(BranchType.TrueBranch, addr + range)
                result.add_branch(BranchType.FalseBranch, addr + 3)
        
        return result
    
    def get_instruction_text(self, data, addr):
        tokens = []
        inst_size = 0
        if data[0] == 0: 
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "HALT"))
            inst_size = 1
        elif data[0] == 1:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "ADD"))
            inst_size = 1
        elif data[0] == 2:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "SUB"))
            inst_size = 1
        elif data[0] == 3:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "AND"))
            inst_size = 1
        elif data[0] == 4:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "OR"))
            inst_size = 1
        elif data[0] == 5:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "XOR"))
            inst_size = 1
        elif data[0] == 6:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "SHL"))
            inst_size = 1
        elif data[0] == 7:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "SHR"))
            inst_size = 1
        elif data[0] == 8:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "GETCHAR"))
            inst_size = 1
        elif data[0] == 9:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "PUTCHAR"))
            inst_size = 1
        elif data[0] == 10:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "PUSH"))
            tokens.append(InstructionTextToken(InstructionTextTokenType.TextToken, '    '))
            tokens.append(InstructionTextToken(InstructionTextTokenType.IntegerToken, hex(data[1]), data[1]))
            inst_size = 2
        elif data[0] in [11, 12, 13]:
            range = ctypes.c_short((data[1] << 8) | data[2]).value + 3
            dstAddr = addr + range
            if data[0] == 11:
                tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "JNZ"))
            elif data[0] == 12:
                tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "JZ"))
            elif data[0] == 13:
                tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "JMP"))
            tokens.append(InstructionTextToken(InstructionTextTokenType.TextToken, '    '))
            tokens.append(InstructionTextToken(InstructionTextTokenType.PossibleAddressToken, hex(dstAddr), dstAddr))
            inst_size = 3
        elif data[0] == 14:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "DROP"))
            inst_size = 1
        elif data[0] == 15:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "DUP"))
            inst_size = 1
        elif data[0] == 16:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "NROT"))
            tokens.append(InstructionTextToken(InstructionTextTokenType.TextToken, '    '))
            tokens.append(InstructionTextToken(InstructionTextTokenType.IntegerToken, hex(data[1]), data[1]))
            inst_size = 2
        elif data[0] == 17:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "EXTRACT"))
            inst_size = 1
        elif data[0] == 18:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "JOIN"))
            inst_size = 1
        elif data[0] == 40:
            tokens.append(InstructionTextToken(InstructionTextTokenType.InstructionToken, "DEBUG"))
            inst_size = 1
        
        if inst_size == 0:
            return None
            
        return tokens, inst_size
    
    def get_instruction_low_level_il(self, data, addr, il):
        return None
    
CVMWhere.register()
```

After using this plugin, binary ninja produce code look like this
![Image](/commons/2023-07-05-uiuctf-2023/img2.PNG)  

If you switch to graph view, it even looks more clearly
![Image](/commons/2023-07-05-uiuctf-2023/img3.PNG) 
With a strong disassembler, reverse engineering the VM code is easy now. 

### Solving script
```python
def de1(c):
    return c ^ (c >> 4)

if __name__ == "__main__":
    flag = ""
    enc_arr_1 = [0x72, 0x1D, 0x6F, 0xA, 0x79, 0x19, 0x65, 0x2, 0x77, 0x47, 0x1D, 0x63, 0x50, 0x22, 0x78, 0x4F, 0x15, 0x60, 0x50, 0x37, 0x5D, 0x7, 0x76, 0x1D, 0x47, 0x37, 0x59, 0x69, 0x1C, 0x2C, 0x76, 0x5C, 0x3D, 0x4A, 0x39, 0x63, 0x2, 0x32, 0x5A, 0x6A, 0x1F, 0x28, 0x5B, 0x6B, 0x9, 0x53, 0x20, 0x4E, 0x7C, 0x8, 0x52, 0x32, 0x0, 0x37, 0x56, 0x7D, 0x7]
    prev = 0
    for c in enc_arr_1:
        de = de1(c) ^ prev
        flag += chr(de)
        prev = de ^ prev
    
    print(flag)
```

flag: `uiuctf{ar3_y0u_4_r3al_vm_wh3r3_(gpt_g3n3r4t3d_th1s_f14g)}`

## vmwhere2

### Challenge overview
![Image](/commons/2023-07-05-uiuctf-2023/img4.PNG)  
Same as vmwhere1. But there are two new instructions added.  
[Download](https://github.com/sigpwny/UIUCTF-2023-Public/tree/main/challenges/rev/vmwhere2/challenge)
  
### Reverse engineering
There are 2 new instructions added
![Image](/commons/2023-07-05-uiuctf-2023/img5.PNG) 

| Ops code    | Instruction      | Description                                                                                     |
|:------------|:-----------------|:------------------------------------------------------------------------------------------------|
| 17          | extract          | Pop a value from stack, converter it to bits (8 bits) and push back bits to stack               |
| 18          | join             | Pop 8 bits from stack then converter it to value and push back to stack (reversed of extract)   |

Luckily almost instruction are the same so we can reused the binary ninja arch plugin. We just need to update 2 new instructions. Here is the result of binary ninja disassembler.

![Image](/commons/2023-07-05-uiuctf-2023/img6.PNG) 

With help of binary ninja disassembler, reverse the VM code is simple now. The logical is program take an input, transform it and compare with a constant.

### Solving script
```python
def encrypt(c):
    sum = 0
    for i in range(0, 8):
        bit = (c >> (7 - i)) & 1

        if bit == 1:
            sum = sum + 1
        sum = sum + sum + sum
        print(sum)
    
    return sum & 0xFF
    
if __name__ == "__main__":
    enc = [0xC6, 0x8B, 0xD9, 0xCF, 0x63, 0x60, 0xD8, 0x7B, 0xD8, 0x60, 0xF6, 0xD3, 0x7B, 0xF6, 0xD8, 0xC1, 0xCF, 0xD0, 0xF6, 0x72, 0x63, 0x75, 0xBE, 0xF6, 0x7F, 0xD8, 0x63, 0xE7, 0x6D, 0xF6, 0x63, 0xCF, 0xF6, 0xD8, 0xF6, 0xD8, 0x63, 0xE7, 0x6D, 0xB4, 0x88, 0x72, 0x70, 0x75, 0xB8, 0x75]
    enc = enc[::-1]
    
    lookup_table = []
    for c in range(0x30, 0x7F):
        lookup_table.append(encrypt(c))
    
    flag = ""
    for c in enc:
        flag += chr(lookup_table.index(c) + 0x30)
    
    print(flag)
```

The script provide `uiuctf{b4s3_3_1s_b4s3d_just_l1k3_vm_r3v3rs1n@}` but actually flag is `uiuctf{b4s3_3_1s_b4s3d_just_l1k3_vm_r3v3rs1ng}`. This is because there are multiple characters which match the comparison. I have to guess a bit.

flag: `uiuctf{b4s3_3_1s_b4s3d_just_l1k3_vm_r3v3rs1ng}`

## Fast Calculator

### Challenge overview
![Image](/commons/2023-07-05-uiuctf-2023/img7.PNG)  

A calculator written in C  
[Download](https://github.com/sigpwny/UIUCTF-2023-Public/tree/main/challenges/rev/fastcalc/challenge)

### Reversing engineering

The code in main look simple. Here is the short version of it
```c
double __usercall calculate@<xmm0>(unsigned int operation, double value_1, double value_2)
{
  double result; // [rsp+8h] [rbp-8h]

  result = 0.0;
  if ( operation > 0x2F )
  {
    if ( operation == 0x5E )
    {
      powf64(value_1, value_2);
      return value_1;
    }
  }
  else if ( operation >= 0x25 )
  {
    switch ( operation )
    {
      case '%':
        fmodf64(value_1, value_2);
        result = value_1;
        break;
      case '*':
        result = value_2 * value_1;
        break;
      case '+':
        result = value_2 + value_1;
        break;
      case '-':
        result = value_1 - value_2;
        break;
      case '/':
        result = value_1 / value_2;
        break;
      default:
        return result;
    }
  }
  return result;
}

int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
    //....
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          printf("Enter your operation: ");
          if ( (unsigned int)_isoc99_scanf((unsigned int)" %lf %c %lf", &value_1, &operation, &value_2) == 3 )
            break;
          while ( (unsigned int)getchar() != 10 )
            ;
        }
        if ( operation == '+'
          || operation == '-'
          || operation == '*'
          || operation == '/'
          || operation == '%'
          || operation == '^' )
        {
          break;
        }
        puts("Invalid operation!");
      }
      calc_result = calculate(operation, value_1, value_2);
      printf("Result: %lf\n", calc_result);
    }
    while ( calc_result != 8573.8567 );
	puts("\nCorrect! Attempting to decrypt the flag...");
    //...
}
```
If our calculated result is `8573.8567`, it will decrypt the flag. Enter the operation `8573.8567 + 0` and it will give us flag 

![Image](/commons/2023-07-05-uiuctf-2023/img8.PNG)  

Or it's not?    
After looking everywhere else I can't find anything so I decided to take a short break. It actually helped. After taking a nap, I carefully looked at every function and found something suspicious. Here is how function `gauntlet` is implemented

```c
__int64 isNotNumber()
{
  return 0LL;
}

__int64 isInfinity()
{
  return 0LL;
}

bool __fastcall isNegative(double a1)
{
  return a1 < 0.0;
}

_BOOL8 __fastcall gauntlet(double input)
{
  return isNegative(input) || (unsigned __int8)isNotNumber() || (unsigned __int8)isInfinity();
}
```

And here is the code that decrypt the flag (rewritten version)
```c
typedef struct operation_s
{
	uint64_t operation;
	double value_1;
	double value_2;
}operation_t;

operation_t ope[368];

//struct g_operation at address: 0x4B8240
memcpy(ope, g_operation, sizeof(ope));

for ( i = 0; i < (int)operation_cnt; ++i )
{
  operation_result = calculate(ope[i].operation, ope[i].value_1, ope[i].value_2);
  if ( gauntlet(operation_result) )
  {
	flag[i / 8] ^= 1 << (7 - i % 8);
	++bit_flipped;
  }
}
```

Function `gauntlet` decides when the encrypted flag is being xored or not. But function `isNotNumber` and `isInfinity` are not implemented. That's weird. Maybe we can reimplement those functions and the flag decryption will run correctly. After an hour I was able to reimplemented the flag decryption in C.

### Solution code
{% raw %}

```c
#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include <stdbool.h>
#include <string.h>

typedef struct operation_s
{
	uint64_t operation;
	double value_1;
	double value_2;
}operation_t;

operation_t g_operation[368] = 
{{0x25, 314.2357223949775, -343.8001815307395},  
{0x2D, 440.2396011722506, 97.06735072845765},  
{0x25, -101.8512648064099, 430.6151228128405},  
{0x2F, 26.56668311805515, -179.0810006863229},
{0x25, -70.14572896052726, -320.1140167220988},
{0x2F, 466.1142124377461, -173.6046119472289},
{0x25, -2.338062192709174, -435.2257228345381},
{0x2D, -214.5366919073277, -300.7554748526087},
{0x5E, -98.75553114434364, 87.0},
{0x2A, -181.2693085201375, -254.2891753858638},
{0x2B, 98.69859205620185, -165.9282391293022},
{0x2B, 116.0274807393475, 321.984734802748},
{0x2D, 327.1750339605699, 389.3991129196481},
{0x2F, 275.8927577139222, 485.1321681765701},
{0x2B, 256.6457520589561, -267.8816101053278},
{0x25, 93.16171654064658, -47.42472178263847},
{0x25, -188.8353781006585, -42.50856926897927},
{0x2B, 297.4652425999785, 114.3820816117981},
{0x25, 45.27256243736304, 126.4536407002288},
{0x2F, 76.3872255137918, -202.6354762198947},
{0x2D, -107.4658375019244, -195.9375676293928},
{0x2D, -318.0072763141803, -202.1613442255964},
{0x5E, 15.23732537118715, 69.04397838106345},
{0x2F, 134.7816754372323, 246.703823912999},
{0x25, 365.5900085787963, -458.2101548302953},
{0x5E, -7.455587224905514, 15.0},
{0x2D, -448.3995644416161, 451.6401344241308},
{0x2B, 195.1954528459836, -3.159313392519607},
{0x2A, -242.3509660767933, -94.05742243049707},
{0x5E, 61.2322120565459, 57.49752960201301},
{0x25, -48.90609517858468, 4.56423488614746},
{0x25, 377.0848901179586, -218.0176934131053},
{0x2D, 436.4717594933577, 406.4606566576994},
{0x2F, 152.3297431295647, -196.0425232932797},
{0x2F, -244.2256960235983, 164.8337946712833},
{0x5E, -32.49558678970489, 45.0},
{0x2B, 329.79729366711, -200.3834005888423},
{0x25, -104.6534460054706, -197.8713050435275},
{0x25, 257.8983468906606, -316.1366955271675},
{0x2B, 257.911427236325, 319.0245191059751},
{0x2F, -200.2108948167093, 424.4058924129766},
{0x2F, 12.6348080835329, -3.014780571255699},
{0x2F, 109.6430999287996, 470.4859112961402},
{0x25, -303.6130095467497, -218.820348750745},
{0x2A, 228.3473127208998, -308.0440675454499},
{0x5E, -56.83925458036938, 37.0},
{0x25, -112.719151748068, -369.8345426832743},
{0x2F, -309.5081470478035, 399.3584020200811},
{0x2F, -319.825976302458, 402.4113805499647},
{0x25, 138.5511892569896, 233.5304639154714},
{0x2A, 252.8509427557718, 248.6332775729791},
{0x5E, -87.21972599004201, 93.0},
{0x5E, 60.51396748080337, 84.93280493871936},
{0x2F, 367.2521504592072, -173.2739137443428},
{0x2B, 448.0756070642373, 378.0243773867894},
{0x2B, -164.0987892761789, -196.6825322013746},
{0x2F, 187.7921615027944, 252.1566128280326},
{0x25, -451.2210317711145, 107.4236721406498},
{0x5E, -462.4113231059457, 0.45391883469417},
{0x25, -218.0568519464934, 218.0568519464934},
{0x5E, -2.933599113641105, 0.9880039025773557},
{0x2B, -412.9196101924579, 386.8483404652185},
{0x25, -129.6221334044602, 129.6221334044602},
{0x5E, 85.4727225760916, 60.60280707580021},
{0x25, -195.8668029679142, 322.7340791332307},
{0x5E, -454.2345921887002, 0.5986235243509275},
{0x2A, -150.2774441921585, -339.4689909684587},
{0x25, -298.6111931473824, 298.6111931473824},
{0x25, -348.3287378284605, -348.3287378284605},
{0x25, -191.183708002151, 175.6137239752665},
{0x2D, 277.2622553928126, 332.0173116431311},
{0x2A, -123.6788254741639, -114.8165309240621},
{0x2B, 351.5064618655932, -132.9687035867513},
{0x5E, 28.45971015414025, 78.31670312375007},
{0x2A, 429.425026465616, -126.5856520588176},
{0x25, -168.0626761959197, -168.0626761959197},
{0x5E, -89.62507013196158, 0.3155272779041431},
{0x5E, -435.6326794910422, -0.5596086982531079},
{0x5E, -77.15234828127994, 55.0},
{0x5E, -122.9345125896663, -0.7607795149051053},
{0x2D, -174.3747454468498, 319.46165358646},
{0x2D, 242.6846228589452, 150.9455824774996},
{0x25, -91.97685860725163, -91.97685860725163},
{0x2F, -294.7693438865663, -52.70287127788441},
{0x25, -351.560219405461, -351.560219405461},
{0x5E, -465.1597433884335, -0.4066417993322355},
{0x2B, -258.1351789609496, -390.0202034371084},
{0x2F, 204.4234984416503, -117.7525625525531},
{0x5E, -98.25095127293328, 7.0},
{0x25, -474.9038530330467, 474.9038530330467},
{0x25, -73.02176814262756, -73.02176814262756},
{0x5E, -480.8538448137391, 0.398084357553655},
{0x2B, -117.6172190098737, 267.2475414840267},
{0x5E, -58.78556412923402, 99.0},
{0x25, -396.205850351399, 396.205850351399},
{0x25, -407.6274284098175, 407.6274284098175},
{0x2A, 85.76775872766427, 207.499089349733},
{0x2D, 283.7822650160952, -188.8255610094685},
{0x25, 8.433308152348104, 441.5776328485609},
{0x2D, -35.13934118818349, 34.20370438881059},
{0x2D, -132.261863763708, -299.2396390165084},
{0x5E, -134.3854656986764, 0.03438468534809336},
{0x25, -140.7542778024738, 140.7542778024738},
{0x2F, 104.7306198463179, -133.1371812731221},
{0x2B, 499.6338403383875, -375.1493166739683},
{0x2B, 269.8641021273513, -294.0303377106679},
{0x25, -422.3084200316476, -422.3084200316476},
{0x2A, -279.6247127256191, 328.6297745060897},
{0x25, -124.6593716706216, 124.6593716706216},
{0x25, -105.4404824224378, 105.4404824224378},
{0x25, -77.94773972339561, -304.9832224900682},
{0x2B, -47.20993775675896, 398.521418779693},
{0x2D, 184.8438705870294, -493.0022358351648},
{0x25, -442.9975947470517, -442.9975947470517},
{0x2A, 242.3322023868459, 251.793050002892},
{0x2B, -357.9762599053308, -372.7422103772925},
{0x5E, -71.45563200217433, 31.0},
{0x25, -491.5161540905127, -491.5161540905127},
{0x25, -108.3078208322917, -108.3078208322917},
{0x2F, -128.3049057057785, -278.0947386342567},
{0x2F, -157.4023143255733, 99.58416190365688},
{0x5E, -321.3781585445645, -0.6700644558926727},
{0x2A, -23.21240272797729, 88.22647796484353},
{0x5E, -140.5686177854314, 0.504094949453963},
{0x2D, -28.42074661091243, 251.5071490698572},
{0x5E, -296.4916789412517, -0.6558120103265221},
{0x5E, -95.9647313235524, 81.0},
{0x25, -251.2374896785937, -251.2374896785937},
{0x2A, 401.2195684810138, -87.26146617045407},
{0x25, -430.3914473035836, 119.8857847200618},
{0x2F, -47.13223233793661, -342.8135618878991},
{0x5E, -410.1417201734874, 0.2856737985264768},
{0x25, -127.6303116389161, -258.2313816238922},
{0x5E, -239.8099457890566, -0.8304690019239958},
{0x25, -8.337783124225041, -226.1832133009058},
{0x25, -397.6308129812426, 397.6308129812426},
{0x2A, -332.6161712384092, -222.2209600170058},
{0x5E, -58.5617119212723, 17.0},
{0x2B, 398.1753260403665, 470.7371679967202},
{0x5E, -290.6646239819354, 0.8688655026214567},
{0x2A, -22.48737271659263, 168.1433671953746},
{0x25, -398.2320277353883, -425.0037211349952},
{0x5E, -394.4010662770377, -0.2470004299243211},
{0x5E, 25.53809520775316, 87.9689525953484},
{0x25, 106.927083151988, 447.9724127881341},
{0x2A, 300.3014078396803, -422.7686180403333},
{0x5E, -320.3751921885789, -0.584235550188261},
{0x25, -90.55138225763498, 90.55138225763498},
{0x5E, -198.0309681245232, -0.8417203693026956},
{0x5E, -18.02709984794343, 0.5363583337842031},
{0x25, -209.95216426976, -209.95216426976},
{0x2F, 166.8419968710618, 71.80435368282588},
{0x2A, -144.0305496940235, -8.140336163817381},
{0x5E, 16.33136828708752, 9.440282839262771},
{0x2D, 318.9528083071659, -100.2682079162638},
{0x5E, -430.5906563191459, -0.0614408665561712},
{0x5E, -177.7056246809666, -0.5100801911793171},
{0x5E, -331.5666856643803, 0.08585569734322762},
{0x5E, 98.51242110201838, 53.26161118637498},
{0x2B, 271.9852320811567, -257.8683166365194},
{0x2B, -264.0902304836538, -406.7189764827539},
{0x5E, -332.619817355589, 0.8074796214553475},
{0x25, -305.1679611331573, 264.9923843230281},
{0x25, -209.284264367343, 209.284264367343},
{0x2D, -489.5331804689474, 45.55528389702715},
{0x5E, -190.353105930031, 0.9279065359789931},
{0x2B, 261.2531827317107, -286.2500835605907},
{0x2F, -211.7995935649794, 472.5204320491},
{0x2A, -54.77665453661893, 403.0065674847991},
{0x5E, -403.0929746531724, -0.2779809723112447},
{0x2A, 163.3847487724289, -407.804988695334},
{0x25, -97.13469326338902, 97.13469326338902},
{0x2F, -455.2966453958188, -95.37703832120013},
{0x5E, -342.3548946789988, -0.116740839234478},
{0x2B, -320.3393319040999, -430.0785255317033},
{0x2D, -458.4787433605626, -60.98519243444821},
{0x2D, 323.4194767543704, -98.03607228783517},
{0x2D, 255.0762587444524, -17.36480177144949},
{0x2A, -159.6071975643947, 249.6944611918228},
{0x2A, 486.1762963487778, 336.85999310445},
{0x5E, -475.2905250578201, 0.8504359483715576},
{0x25, -36.80035873623378, -36.80035873623378},
{0x25, -182.3481923098414, 182.3481923098414},
{0x2D, 467.7766551403014, -441.2925115214279},
{0x2A, 266.419417360063, -63.97541807056751},
{0x2F, -304.112947522169, -461.3144461217887},
{0x25, -365.5990592247167, -365.5990592247167},
{0x5E, -297.4699378784764, -0.5773872658138688},
{0x2B, 307.3514457033476, -25.71084603805105},
{0x5E, -71.69747272483716, 73.0},
{0x25, -326.5610378443252, -326.5610378443252},
{0x25, -168.7930204966482, 168.7930204966482},
{0x2B, 433.4071146420388, -70.66991804550861},
{0x5E, -81.77515455506939, 0.3091059163191576},
{0x2F, 445.1820075814234, -320.6557865724515},
{0x5E, -91.74842333494809, 0.06717543061049813},
{0x25, 259.1436558203844, -165.9902808355893},
{0x25, 13.01368911018096, -436.9307726068344},
{0x2F, 332.8834822252668, 168.9209676587349},
{0x5E, -335.0084509762081, 0.8090072521240703},
{0x2D, 119.4915034224593, 452.1997536582252},
{0x2F, -33.61544529448537, 226.6144682430429},
{0x25, 368.8840503941358, 358.982324427181},
{0x2A, -105.4676334986975, -301.9189918381502},
{0x2F, 270.7856335602969, 86.78310539196082},
{0x25, -79.23893586760383, -79.23893586760383},
{0x2A, 65.37616989637559, 250.5824214926186},
{0x5E, -247.7894028706231, -0.5764870534825064},
{0x5E, -80.43263965418926, 97.0},
{0x5E, -229.7856433443393, 0.5231194333156883},
{0x2D, -291.9159102748514, -117.1303965238492},
{0x5E, -460.19160518211, 0.7310191131580686},
{0x25, -287.141533578852, -287.141533578852},
{0x25, -165.0996822871327, -165.0996822871327},
{0x2A, 27.70368031437579, -71.75522123743758},
{0x25, -166.2734558827129, -166.2734558827129},
{0x25, 318.670292004714, 457.7699437880531},
{0x5E, -350.8241982853795, 0.5284536581380765},
{0x25, 65.16561987924581, 138.0752858271028},
{0x2B, -81.47431401565927, 101.82753628118},
{0x2F, 346.8367319876498, -472.5983232778733},
{0x2D, -495.3138954602319, -229.065771643326},
{0x25, -205.6747798441199, -205.6747798441199},
{0x25, -267.1057892244319, 267.1057892244319},
{0x2B, 329.258582041222, -216.9752706836806},
{0x2B, -377.8169727772211, -397.2714908525516},
{0x25, -44.50526642739289, -44.50526642739289},
{0x2D, 239.7707880974558, 363.2672652022848},
{0x25, -175.5576813832685, -175.5576813832685},
{0x5E, -212.4513869895544, 0.2278950565833462},
{0x25, 68.32948123433016, -258.7275703164208},
{0x2A, 496.1765032584909, 85.08382046982376},
{0x2B, -236.0943692615206, 105.1151916830931},
{0x2A, -348.9908893855387, -84.33677295878681},
{0x2D, -470.7916526905721, 407.7199915901973},
{0x5E, -346.4649933067601, 0.01420411387208254},
{0x25, -402.6366504242033, 402.6366504242033},
{0x25, -269.3054182939108, -269.3054182939108},
{0x25, 306.402809193317, 344.8824810516929},
{0x25, -202.0004386933506, 202.0004386933506},
{0x2F, -55.4636123392691, 269.633308481816},
{0x25, -416.4903044922913, -416.4903044922913},
{0x2D, 64.53465923964779, 16.9614966787243},
{0x25, 470.5512565280966, 63.93156807293724},
{0x2B, 175.4690770242486, 202.9789580190223},
{0x5E, -344.3945767445645, 0.3299293616716132},
{0x25, -243.310494661645, 243.310494661645},
{0x5E, 3.640618141783103, 82.06735032439116},
{0x2D, 218.2979179893825, 428.6472666309246},
{0x5E, -259.4902581833767, -0.6695647693798996},
{0x25, -73.94952201977777, 73.94952201977777},
{0x5E, -338.6706419714745, -0.3777617187065907},
{0x5E, -467.8256995353506, 0.2042546775516509},
{0x25, -222.6666729851796, -222.6666729851796},
{0x25, -379.8198362605958, -379.8198362605958},
{0x25, -440.7643880192924, -440.7643880192924},
{0x2F, -301.309663417501, 273.7430250482557},
{0x25, -371.8141950545257, -345.4138044144127},
{0x2D, 404.1803168174017, 6.694178373420812},
{0x2A, 102.1804066618055, 377.0374946785261},
{0x25, 30.648157313301, -338.5609672152443},
{0x2F, -104.6637760089864, -16.89343705748416},
{0x25, -429.9494515933901, -429.9494515933901},
{0x5E, -444.676343432401, -0.674247986309302},
{0x2F, -139.6314841276451, -196.8664533654221},
{0x25, -17.5216846206559, -17.5216846206559},
{0x5E, 9.3482479857215, 27.06791700008178},
{0x2F, 68.28691457053867, 403.9415327452344},
{0x5E, 75.84886038832583, 49.00829075342995},
{0x2D, 207.5824643733607, 26.38786096331091},
{0x5E, -452.9766678962322, -0.1470782617786868},
{0x5E, -484.702468340655, 0.4348512994528775},
{0x2B, 48.46351179981991, 176.8359087123727},
{0x2B, -44.40364055737342, -140.9927317322635},
{0x2B, 491.125447744961, -132.9323605643697},
{0x25, -401.950502789964, 401.950502789964},
{0x25, 95.61728073065797, -211.6901502260675},
{0x2A, 283.0011012270334, 229.0547798138675},
{0x5E, -93.11166355230489, 67.0},
{0x5E, -363.2919677291165, 0.6544511415975767},
{0x2D, -14.56390562101365, -295.435280853623},
{0x25, -493.4958365346321, 493.4958365346321},
{0x5E, -16.39177970702201, 89.0},
{0x5E, -474.0240219161051, 0.4096959979051376},
{0x5E, -79.55270502953854, 69.0},
{0x2F, 53.95071213569338, 383.2288410982533},
{0x25, -93.79417632230607, 93.79417632230607},
{0x25, -463.2880436743698, 463.2880436743698},
{0x25, 45.18720898641538, -39.86790896724335},
{0x2D, 202.919996750724, -324.1640355856202},
{0x5E, -194.6928863971034, -0.5776762313604342},
{0x2D, -330.1836915186407, -297.8841387051982},
{0x5E, -1.505471684641491, -0.7178150526698348},
{0x5E, -96.60808659377845, 41.0},
{0x25, -149.6662441491185, -149.6662441491185},
{0x25, -367.147354687935, -367.147354687935},
{0x5E, 12.00574207958378, 29.7411717239969},
{0x2F, -237.2787164054493, 255.7049331234037},
{0x2A, -482.697597612631, -454.7352400650691},
{0x5E, 77.73409264992017, 30.84698085517126},
{0x5E, 66.66469898603206, 62.07260194648222},
{0x2F, 344.399108084358, -330.9725139372987},
{0x5E, -83.51826090519724, 75.0},
{0x2B, -67.66823474154336, -11.9163074811305},
{0x2A, -359.4430859114567, 408.8380987523959},
{0x5E, -53.98972277590986, 61.0},
{0x2F, -272.6464875425866, -52.3894271169666},
{0x2A, 370.6127105288062, 184.7601646528367},
{0x25, -361.9152834419255, 361.9152834419255},
{0x2D, -467.1369737578626, -203.2647235429723},
{0x2D, 278.3826603132402, 415.5301997167533},
{0x5E, -301.0674635316377, 0.8291233788823997},
{0x25, 472.3230422807608, 81.34762990120385},
{0x25, -107.6019455536639, 107.6019455536639},
{0x5E, -310.4072515630693, 0.6259231486837773},
{0x5E, -9.486913237689354, 0.7907695910004302},
{0x25, -120.2965557997258, -120.2965557997258},
{0x5E, -163.3746673722815, 0.8650593011671992},
{0x25, -156.7172695045408, 156.7172695045408},
{0x5E, -64.61051074257939, -0.09947667609772903},
{0x5E, 63.50062738464233, 33.98324540312984},
{0x25, 386.1287081725886, -107.0683051959106},
{0x25, -380.7316794594457, -380.7316794594457},
{0x2B, 159.0706948979946, 250.3209029299124},
{0x5E, -4.873245128917736, -0.3744177907258202},
{0x2B, 2.458901363309735, 161.1052606563139},
{0x25, -41.19941306413616, -41.19941306413616},
{0x5E, -496.0770737355603, -0.8111795106414499},
{0x5E, -38.61374487658282, 39.0},
{0x2F, 187.6185181209879, -303.9626655156481},
{0x2A, 151.7987367885288, 167.6401241042125},
{0x25, -128.934289153541, 87.08867897625782},
{0x2F, 489.4137106489145, 196.582231326621},
{0x2F, 313.9038651494064, 307.5119180799759},
{0x2A, -318.7807743336529, 106.4735256784152},
{0x25, 244.9868689086973, 19.76045054826488},
{0x2F, -218.3810253554403, 56.31653756207947},
{0x2F, -321.4690899762336, 471.9987596968062},
{0x25, -468.8507521901163, -468.8507521901163},
{0x2B, -230.1989105358542, -454.9760495300287},
{0x25, -413.0430009119941, -10.94670354406912},
{0x5E, -51.3107384610953, 0.9548851577999304},
{0x25, -377.2368844087873, 377.2368844087873},
{0x25, -103.701656465033, -103.701656465033},
{0x25, 285.9225420857967, -378.089856913595},
{0x25, -287.4060970240897, -407.3234417777463},
{0x2D, 443.2396196174817, -25.4607369662653},
{0x5E, -125.3965698755341, -0.2282006760280357},
{0x25, -239.3594747454114, -239.3594747454114},
{0x25, -4.736105526029322, -4.736105526029322},
{0x25, 58.03201117994729, -290.0824981866179},
{0x5E, -93.08388076635198, 77.0},
{0x5E, -29.63159513789518, 23.0},
{0x25, -166.0881694563761, 166.0881694563761},
{0x2F, 463.8995072847684, 332.1402224867336},
{0x25, -112.0583839736099, -112.0583839736099},
{0x2D, -131.1830696148209, -224.193419050567},
{0x25, -358.3139008529167, -269.1094759160254},
{0x25, -160.9933645098241, 160.9933645098241},
{0x25, -126.55669891797, 360.6922891350808},
{0x2D, -305.1095912540707, 308.4690271754432},
{0x25, 352.8361527177763, -191.4712824016095},
{0x2B, 89.61508900847014, 89.1234497989733},
{0x2B, -203.1481381321765, 117.5727604268772},
{0x5E, 66.37433504049558, 14.78144158866414},
{0x5E, -39.73744088699632, 55.0},
{0x2F, 443.9210534918399, 53.74338477053027},
{0x2F, -0.4580954923237641, -214.804781136109}};


double calculate(uint64_t ope, double value_1, double value_2)
{
	switch (ope)
	{
	case 0x5E:
		return pow(value_1, value_2);
	case 0x25:
		return fmod(value_1, value_2);
	case 0x2A:
		return value_1 * value_2;
	case 0x2B:
		return value_1 + value_2;
	case 0x2D:
		return value_1 - value_2;
	case 0x2F:
		return value_1 / value_2;
	default:
		{
			printf("WTF???\n");
			return 0;
		}
	}
	return 0;
}

bool isNegative(double input)
{
	return input < 0.0;
}

bool isNotNumber(double input)
{
	return isnan(input);
}

bool isInfinity(double input)
{
	//return isinf(input);
	return !(isnormal(input));
}

bool gauntlet(double input)
{
	return (isNegative(input) || isNotNumber(input) || isInfinity(input));
}

int main()
{
	
	char enc[46];
	
	//I know this is stupid but it works
	*(uint64_t *)enc = 0x10EEB90001E1C34BLL;
	*(uint64_t *)&enc[8] = 0xCB382178A4F04BEELL;
	*(uint64_t *)&enc[16] = 0xE84683CE6B212AEALL;
	*(uint64_t *)&enc[24] = 0xA0F5CF092C8CA741LL;
	*(uint64_t *)&enc[32] = 0x20A92860082772A1LL;
	*(uint32_t *)&enc[40] = 0x35ABB366;
	*(uint16_t *)&enc[44] = 0xE9A4;
	
	for (int i = 0; i < 368; i++)
	{
		double v6 = calculate(g_operation[i].operation, g_operation[i].value_1, g_operation[i].value_2);
		if ( gauntlet(v6) )
			enc[i / 8] ^= 1 << (7 - i % 8);
	}
	
	printf("%s\n", enc);
}
```

{% endraw %}

I don't know why `isinf` does not work so I use `!isnormal` instead. After compile and run, the program gives me the correct flag
flag: `uiuctf{n0t_So_f45t_w1th_0bscur3_b1ts_of_MaThs}`

Fact: After looking at discord chat, the binary might be compiled with flag `fast-math` so it striped the function `isNotNumber` and `isInfinity`. That makes sense. Further reading [here](https://simonbyrne.github.io/notes/fastmath/)